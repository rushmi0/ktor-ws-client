<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DeveloperToolsToolWindowSettingsV1" lastSelectedContentNodeId="notes">
    <developerToolsConfigurations>
      <developerToolConfiguration developerToolId="notes" id="d40c90d7-ee78-4e31-b492-fd45962b30e3" name="Workbench">
        <properties>
          <property key="test" type="INPUT" value="kotlin.String|[&quot;EVENT&quot;,&quot;hsZEO2taDsENYkP5H-JIWp&quot;,{&quot;id&quot;:&quot;8ae831cca4c109bb3587c521f5095fe32cb6366d7f4590b3e3e46b99fbb3e449&quot;,&quot;pubkey&quot;:&quot;f03df3d4134230420cdf7acbb35f96a2542424246ab052ba24c6fec6a4d4f676&quot;,&quot;created_at&quot;:1731768350,&quot;kind&quot;:1,&quot;tags&quot;:[],&quot;content&quot;:&quot;Block 870571\n\n7 - high priority\n6 - medium priority\n5 - low priority\n2 - no priority\n1 - purging\n\n#bitcoinfees #mempool&quot;,&quot;sig&quot;:&quot;980060b3929b2d242efe71bedd5a85466133f95f812860b31cf1be82ee818c75c1af84eab1e066edec55015ef0a97aca969ce047e9cba5ad84ba72ab2d0be576&quot;}]&#10;" />
        </properties>
      </developerToolConfiguration>
      <developerToolConfiguration developerToolId="notes" id="535a4eaf-c0a9-4349-aa8a-1d3bd5bed170" name="Workbench">
        <properties>
          <property key="test" type="INPUT" value="kotlin.String|แก้ไขอย่างไร&#10;&#10;&#10;Exception in thread &quot;main&quot; kotlinx.serialization.SerializationException: Serializer for class 'ReceiveEvent' is not found.&#10;Please ensure that class is marked as '@Serializable' and that the serialization compiler plugin is applied.&#10;&#10;&#9;at kotlinx.serialization.internal.Platform_commonKt.serializerNotRegistered(Platform.common.kt:90)&#10;&#9;at kotlinx.serialization.SerializersKt__SerializersKt.serializer(Serializers.kt:299)&#10;&#9;at kotlinx.serialization.SerializersKt.serializer(Unknown Source)&#10;&#9;at io.ktor.serialization.kotlinx.SerializerLookupKt.serializerForTypeInfo(SerializerLookup.kt:30)&#10;&#9;at io.ktor.serialization.kotlinx.KotlinxWebsocketSerializationConverter.deserialize(KotlinxWebsocketSerializationConverter.kt:48)&#10;&#9;at io.ktor.websocket.serialization.WebsocketChannelSerializationKt.receiveDeserializedBase(WebsocketChannelSerialization.kt:105)&#10;&#9;at io.ktor.client.plugins.websocket.ClientSessionsKt.receiveDeserialized(ClientSessions.kt:100)&#10;&#9;at org.demo.MainKt$main$1$1.invokeSuspend(Main.kt:77)&#10;&#9;at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)&#10;&#9;at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:101)&#10;&#9;at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:263)&#10;&#9;at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:95)&#10;&#9;at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:69)&#10;&#9;at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)&#10;&#9;at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:47)&#10;&#9;at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)&#10;&#9;at org.demo.MainKt.main(Main.kt:54)&#10;&#9;at org.demo.MainKt.main(Main.kt)&#10;&#10;&#10;&#10;&#10;package org.demo&#10;&#10;import io.ktor.client.*&#10;import io.ktor.client.engine.cio.*&#10;import io.ktor.client.plugins.websocket.*&#10;import io.ktor.http.*&#10;import io.ktor.serialization.kotlinx.*&#10;import io.ktor.websocket.*&#10;import kotlinx.coroutines.*&#10;import kotlinx.serialization.json.Json&#10;&#10;&#10;import kotlinx.serialization.SerialName&#10;import kotlinx.serialization.Serializable&#10;&#10;@Serializable&#10;data class ReceiveEvent(&#10;    val type: String, // &quot;EVENT&quot;&#10;    val subscriptionId: String,&#10;    val event: Event&#10;)&#10;&#10;@Serializable&#10;data class Event(&#10;    val id: String,&#10;    val pubkey: String,&#10;    @SerialName(&quot;created_at&quot;) val createdAt: Long,&#10;    val kind: Int,&#10;    val tags: List&lt;String&gt;,&#10;    val content: String,&#10;    val sig: String&#10;)&#10;&#10;&#10;// * https://ktor.io/docs/client-websockets.html#frame-types&#10;fun main() {&#10;    val client = HttpClient(CIO) {&#10;        install(WebSockets) {&#10;            pingIntervalMillis = 20_000&#10;            contentConverter = KotlinxWebsocketSerializationConverter(Json)&#10;        }&#10;        engine {&#10;            endpoint {&#10;                // this: EndpointConfig&#10;                maxConnectionsPerRoute = 100&#10;                pipelineMaxSize = 20&#10;                keepAliveTime = 5000&#10;                connectTimeout = 5000&#10;                connectAttempts = 5&#10;            }&#10;        }&#10;    }&#10;&#10;    runBlocking {&#10;        client.webSocket(&#10;            method = HttpMethod.Get,&#10;            host = &quot;relay.rushmi0.win&quot;,&#10;            path = &quot;/&quot;&#10;        ) {&#10;&#10;            val cmd = &quot;&quot;&quot;[&quot;REQ&quot;,&quot;hsZEO2taDsENYkP5H-JIWp&quot;,{&quot;limit&quot;: 100}]&quot;&quot;&quot;&#10;            send(cmd)&#10;&#10;            for (frame in incoming) {&#10;                if (frame is Frame.Text) {&#10;                    val data = receiveDeserialized&lt;ReceiveEvent&gt;()&#10;                    //println(&quot;Received: ${frame.readText()}&quot;)&#10;                    println(data)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    client.close()&#10;}&#10;" />
        </properties>
      </developerToolConfiguration>
      <developerToolConfiguration developerToolId="notes" id="d40803a9-8be1-449d-9911-834ea282cedc" name="Workbench">
        <properties>
          <property key="test" type="INPUT" value="kotlin.String|&#10;        override fun onMessage(webSocket: WebSocket, text: String) {&#10;            val data = text.toJsonEltArray()&#10;            if (data[0].jsonPrimitive.content == &quot;EVENT&quot;) {&#10;                runBlocking { receivedEvent(data[2].jsonObject) }&#10;            }&#10;        }&#10;&#10;        private suspend fun receivedEvent(eventJson: JsonObject) {&#10;            val event: Event = eventJson.toEvent()&#10;            val eventMap: Map&lt;String, JsonElement&gt; = eventJson.toMap()&#10;&#10;            val (status, _) = validateElement(eventMap, EventValidateField.entries.toTypedArray())&#10;            if (status) {&#10;                handleEvent(event) {&#10;                    val eventId: Event? = runBlocking { sqlExec.selectById(event.id!!) }&#10;&#10;                    if (eventId == null) {&#10;                        LOG.info(&quot;Event ID: $eventId&quot;);&#10;                        sqlExec.saveEvent(event)&#10;                    } else {&#10;                        false&#10;                    }&#10;                }&#10;            }&#10;        }&#10;" />
        </properties>
      </developerToolConfiguration>
    </developerToolsConfigurations>
  </component>
</project>